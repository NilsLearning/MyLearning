---
概要: 学习算法-二分查找

---
>唐纳德·克努特（Donald E.Knuth）在《计算机程序设计艺术》的第 3 卷《排序和查找》中说到：“尽管第一个二分查找算法于 1946 年出现，然而第一个完全正确的二分查找算法实现直到 1962 年才出现
> 假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？


### 1.二分查找 
二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想，其时间复杂度是O(logn)
- 二分查找实现的方式：循环或递归
> * 学习代码: [BinarySearch.java](BinarySearch.java)

>O(logn) 这种对数时间复杂度。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效。为什么这么说呢？
>因为 logn 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，
>如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值，
>比如 O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高。

### 2.变形的二分查找
- 例如：
  - 查找第一个值等于给定值的元素
  - 查找最后一个值等于给定值的元素
  - 查找第一个大于等于给定值的元素
  - 查找最后一个小于等于给定值的元素
  
> * 学习代码: [MySearch.java](MySearch.java)
 
### 3.如何快速定位出一个 IP 地址的归属地？
如果我们有12W条IP地址和归属地信息，但这12W条信息不经常变化，我们可以现将这12W条IP转成12W条32位的整型数，然后从小到大
进行有序排列，接着使用二分查找最后一个小于等于给定值的元素的方法找到这个IP对应的锁定区间，然后对这些IP进行比对，找到了
则进行返回，没有则返回false。



### 总结
如果数据用链表存储，二分查找的时间复杂度就会变得很高。
凡是用二分查找能解决的，绝大部分我们更倾向于用散列表或者二叉查找树。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。
那二分查找真的没什么用处了吗？实际上，上一节讲的求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在“近似”查找问题，
在这类问题上，二分查找的优势更加明显。比如今天讲的这几种变体问题，用其他数据结构，比如散列表、二叉树，就比较难实现了
