---
概要: 学习算法-排序

---

> 排序算法介绍: https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ
> 分治是一种思想，递归是一种编程技巧

### 1.排序方法
  ![img.png](排序算法.png)

### 2.如何分析一个"排序算法"
<1>算法的执行效率
- 最好、最坏、平均情况时间复杂度。
- 时间复杂度的系数、常数和低阶。
- 比较次数，交换（或移动）次数。    

<2>排序算法的稳定性  
- 稳定性概念：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
- 稳定性重要性：可针对对象的多种属性进行有优先级的排序。
- 举例：给电商交易系统中的“订单”排序，按照金额大小对订单数据排序，对于相同金额的订单以下单时间早晚排序。用稳定排序算法可简洁地解决。先按照下单时间给订单排序，排序完成后用稳定排序算法按照订单金额重新排序。

<3>排序算法的内存损耗  
- 原地排序算法：特指空间复杂度是O(1)的排序算法。

### 3.排序算法:
<1>冒泡排序
- 概念：冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。
- 稳定性：冒泡排序是稳定的排序算法。
- 空间复杂度：冒泡排序是原地排序算法。
- 时间复杂度：
  - 最好情况（满有序度）：O(n)。
  - 最坏情况（满逆序度）：O(n^2)。
  - 平均情况：
       “有序度”和“逆序度”：对于一个不完全有序的数组，如4，5，6，3，2，1，有序元素对为3个（4，5），（4，6），（5，6），有序度为3，逆序度为12；对于一个完全有序的数组，如1，2，3，4，5，6，有序度就是n*(n-1)/2，也就是15，称作满有序度；逆序度=满有序度-有序度；冒泡排序、插入排序交换（或移动）次数=逆序度。
       最好情况下初始有序度为n*(n-1)/2，最坏情况下初始有序度为0，则平均初始有序度为n*(n-1)/4，即交换次数为n*(n-1)/4，因交换次数<比较次数<最坏情况时间复杂度，所以平均时间复杂度为O(n^2)

<2>插入排序
- 概念：插入排序将数组数据分成已排序区间和未排序区间。初始已排序区间只有一个元素，即数组第一个元素。在未排序区间取出一个元素插入到已排序区间的合适位置，直到未排序区间为空。
- 空间复杂度：插入排序是原地排序算法。
- 时间复杂度：
  - 最好情况：O(n)。
  - 最坏情况：O(n^2)。
  - 平均情况：O(n^2)（往数组中插入一个数的平均时间复杂度是O(n)，一共重复n次）。
- 稳定性：插入排序是稳定的排序算法。

<3>选择排序
- 概念：选择排序将数组分成已排序区间和未排序区间。初始已排序区间为空。每次从未排序区间中选出最小的元素插入已排序区间的末尾，直到未排序区间为空。
- 空间复杂度：选择排序是原地排序算法。
- 时间复杂度：（都是O(n^2)）
  - 最好情况：O(n^2)。
  - 最坏情况：O(n^2)。
  - 平均情况：O(n^2)。
- 稳定性：选择排序不是稳定的排序算法。

<4>归并排序 
> 学习代码:
> * [MergeSort.java](MergeSort.java)

<5>快速排序
**快排核心思想就是分治和分区**

> 学习代码:
> * [QuickSort.java](QuickSort.java)   

<6>桶排序
将要排序的元素放进几个有序的桶里，对桶里的元素进行排序，然后按照桶的顺序依次将数据拿出，即可排好序
> 缺点：排序的元素需要分布比较均匀

<7>计数排序
> 缺点：只能对非负整数进行排序，但是可以对将数据进行处理，比如每个元素加上1000，对与小数，可以根据需要扩大指定倍数

<8>基数排序
> 缺点：数据可以分割出独立的"位"进行比较
比如对手机号码进行排序，或者对牛津词典中的单词进行排序，那么可能需要对单词进行补位操作

### 4.如何实现一个通用的,高性能的排序函数
- Java语言的数组排序源码是如何实现的呢？
  - 以JDK 1.8的排序来说，可分为数组的排序，和集合的排序，具体实现分别对应工具类Arrays.sort()方法和Collection.sort()方法，其中Collections.sort()是将
  集合转换为数组，然后调用Arrays.sort()方法，在Arrays.sort方法中，排序元素可分为两大类，一类是基本数据类型，一类是对象数据类型，在基本数据类型排序时，
  根据数组的长度不同，会使用不同的排序算法，比如在数组长度小于47时，会使用插入排序，在数组长度在47到286时，会使用快速排序。其具体源码在DualPivotQuicksort类中，对于对象数据类型的排序，根据是否传入了类比较器，会选择
  ComparableTimSort.sort()方法和TimSort.sort()方法
  

> 参考：https://blog.csdn.net/qq_44709990/article/details/122201673

### 实际应用
- 如何用快排思想在O(n)内找寻第K大元素？
  - 利用快排思想根据分区点左右两侧与K值的大小进行比较，不断递归，直至分区点+1=K，此时从数组中取出分区点即为第K大元素
- 如何根据年龄给100万用户排序
- 如何根据分数给全国考生进行排名
- 如何对数字，大小写字母进行排序
  - 都可以利用桶排序
 


### 5.实际工作技巧
选择排序和插入排序的时间复杂度相同，都是O(n^2)，在实际的软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序算法呢？   
答：从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个，所以在对相同数组进行排序时，冒泡排序的运行时间理论上要长于插入排序。


### 总结
- 归并是先分解再合并排序，最后需要复制回原数组，而快速是先分区排序后分解排序即可。
- 桶排序，计数排序，基数排序都不涉及元素之间的比较操作
- 线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法
- 快排在最坏情况下的时间复杂度是 O(n2)，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是 O(nlogn)，从这点上看起来很诱人，那为什么它还是没能得到“宠信”呢？
  - 答：归并排序并不是原地排序算法，空间复杂度是 O(n)。所以，粗略点、夸张点讲，如果要排序 100MB 的数据，除了数据本身占用的内存之外，排序算法还要额外再占用 100MB 的内存空间，空间耗费就翻倍了
> 一个小技巧：如何在不声明中间值的情况下对数组中的两个位进行交换操作
> 答：在Java中可以使用^操作符
> 代码如下：
```
ints[i] ^= ints[j]
ints[j] ^= ints[i]
ints[i] ^= ints[j]
```
- 通用排序函数实现技巧
  - 数据量不大时，可以采取用时间换空间的思路
  - 数据量大时，优化快排分区点的选择
  - 防止堆栈溢出，可以选择在堆上手动模拟调用栈解决
  - 在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n^2)级别的插入排序
  - 用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致

