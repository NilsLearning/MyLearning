---
概要: 围绕 Java 语言基本特性和机制，由点带面，让你构建牢固的 Java 技术功底

---

> **课程资料来源:** 极客时间-《Java 核心技术面试精讲》 杨晓峰

### 1.谈谈你对JAVA的理解
java是一个面向对象，跨平台，实现了垃圾自动回收的开发语言，它之所以能够跨平台，是因为在不同的操作系统需要提前安装对应操作系统的JVM
另外在目前的主流的JDK版本中，如 JDK 8 实际是解释和编译混合的一种模式，提供了 JIT（Just-In-Time）编译器，JIT 能够在运行时将热点
代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。

---
### 2.Exception和Error有啥区别
Exception和Error都继承了Throwable类
Exception是程序正常运行中，可能出现的情况，应该予以处理，处理方式：1.捕获 try……catch  2.向上抛出 3.交由JVM处理
![img.png](异常树.png)

- 异常处理的基本原则
  - 1.尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常    
  泛泛的 Exception 之类，恰恰隐藏了我们的目的。另外，我们也要保证程序不会捕获到我们不希望捕获的异常。比如，你可能更希望 RuntimeException 被扩散出来，而不是被捕获
  - 2.不要生吞（swallow）异常
  生吞异常，往往是基于假设这段代码可能不会发生，或者感觉忽略异常是无所谓的，但是千万不要在产品代码做这种假设！好的方式：
  使用产品日志，详细地输出到日志系统里
  - 3.Throw early, catch late
  例如以下❌代码
    ```
    public void readPreferences(String fileName){
     //...perform operations... 
    InputStream in = new FileInputStream(fileName);
     //...read the preferences file...
    }
    ```
    如果 fileName 是 null，那么程序就会抛出 NullPointerException，但是由于没有第一时间暴露出问题，堆栈信息可能非常令人费解，往往需要相对复杂的定位    
  正确代码：
    ``` 
    public void readPreferences(String filename) {
    Objects. requireNonNull(filename);
    //...perform other operations... 
    InputStream in = new FileInputStream(filename);
    //...read the preferences file...
    }
    ```
- Java 的异常处理机制对性能的影响:
  - 1.try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，
  利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效        
  - 2.Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了
---

### 3.谈谈final，finally，finalize有什么不同
- final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）   
- finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作   
- finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated
> - final的好处
>   - 使用 final 修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成 final    
>   - final 变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要
> - 关于finally
>   - 更推荐使用 Java 7 中添加的 try-with-resources 语句，因为通常 Java 平台能够更好地处理异常情况，编码量也要少很多，何乐而不为呢
> - 为什么finalize被弃用
>   - 你无法保证 finalize 什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。
#### 3.1 final 不是 immutable
比如如下代码：
```
 final List<String> strList = new ArrayList<>();
 strList.add("Hello");
 strList.add("world");  
 List<String> unmodifiableStrList = List.of("hello", "world");
 unmodifiableStrList.add("again");
```
final 只能约束 strList 这个引用不可以被赋值，但是 strList 对象行为不被 final 影响，添加元素等操作是完全正常的。如果我们真的希望对象本身是不可变的，那么需要相应的类支持不可变的行为。在上面这个例子中，
List.of 方法创建的本身就是不可变 List，最后那句 add 是会在运行时抛出异常的    

> Immutable 在很多场景是非常棒的选择，某种意义上说，Java 语言目前并没有原生的不可变支持，如果要实现 immutable 的类，我们需要做到:
>   - 将 class 自身声明为 final，这样别人就不能扩展来绕过限制了。
>   - 将所有成员变量定义为 private 和 final，并且不要实现 setter 方法。
>   - 通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。
>   - 如果确实需要实现 getter 方法，或者其他可能会返回内部状态的方法，使用 copy-on-write 原则，创建私有的 copy

#### 3.2 有什么机制可以替换 finalize 吗?
Java 平台目前在逐步使用 java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。Cleaner 的实现利用了幻象引用（PhantomReference），这是一种常见的所谓 post-mortem 清理机制

### 4.强引用、软引用、弱引用、幻象引用有什么区别？
- 1 强引用
特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。
- 2 软引用
特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。
应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
- 3 弱引用
弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
应用场景：弱应用同样可用于内存敏感的缓存。
- 4 虚引用
特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
ReferenceQueue queue = new ReferenceQueue ();
PhantomReference pr = new PhantomReference (object, queue);
程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。
应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。

### 5.String、StringBuffer、StringBuilder有什么区别？
 - 1.String是immutable的典型实现，当通过String str = '字符串'的方式创建一个字符串时，此时的str会去字符串常量池当中寻找，如果有则将str指向该引用，没有则会缓存到常量池当中，但是这样
 创建的字符串在jdk6以下的版本当中，由于字符串常量池缓存有大量的字符串，其位于永久代，不会被垃圾回收期所回收，所以可能会导致OOM异常，这个问题在之后的jdk版本中通过原空间的方式得到了处理。
 而直接new出来的字符串，则会直接进行字符串对象创建
 - 2.StringBuffer是线程安全的可变字符串，StringBuilder是线程不安全的可变字符串
 - 3.JDK9之前，java的字符串使用char数组来存储的，这样对于拉丁语系的语言，这样的方式比较费内存，jdk9改为byte数组，加上一个标识编码所谓的coder，并且将相关字符串的操作类都进行了修改，
 以此优化了char数组存储字符串的情况
 
### 6.动态代理基于什么原理？
> 编程语言通常有各种不同的分类角度，动态类型和静态类型就是其中一种分类角度，简单区分就是语言类型信息是在运行时检查，还是编译期检查。
> 那么，如何分类 Java 语言呢？通常认为，Java 是静态的强类型语言，但是因为提供了类似反射等机制，也具备了部分动态类型语言的能力。

> 代理分为静态代理和动态代理
> 静态代理：事先定义好代理类
> 动态代理：运行时自动生成代理对象。缺点是生成代理代理对象和调用代理方法都要额外花费时间
> 反射最大的作用之一就在于我们可以不在编译时知道某个对象的类型，而在运行时通过提供完整的”包名+类名.class”得到。注意：不是在编译时，而是在运行时。

动态代理实现方式，比如利用字节码操作机制，类似 ASM、CGLIB（基于 ASM）、Javassist 等
这里主要说一下SpringAOP实现动态代理的两种方式和区别:
- JDK Proxy的代理：
  - 最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。
  - 平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。
  - 代码实现简单。
- Cglib proxy的代理：
   - 有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。
   - 只操作我们关心的类，而不必为其他相关类增加工作量。
   - 高性能。

### 7.int和Integer有什么区别？
int是一个基础数据类型，其数据存在栈中，可直接获取，Integer是对象数据类型，其数据存在堆中，首先找的是一个引用地址（Reference），
然后根据引用地址找到堆中存储的数据，但是Integer的计算性能不如int，而对于更复杂的数据处理，那么Integer能够提供更广泛的操作，
于是JAVA设计者的初衷估计是这样的：如果开发者要做计算，就应该使用primitive value如果开发者要处理业务问题，就应该使用object，采用Generic机制；
反正JAVA有auto-boxing/unboxing机制，对开发者来讲也不需要注意什么。然后在JDK5中，为了弥补object计算能力的不足，还设计了static valueOf()方法提供缓存机制，
算是一个弥补。
> 这里隐含的知识点：
> Java为啥要有自动拆箱和装箱操作，这是因为原始数据类型(Primitive Types)和泛型(Generic )不能混用， 
> Java 的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，
> 但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制  
> 对象的储存结构：
> 1. Mark Word:标记位 4字节，类似轻量级锁标记位，偏向锁标记位等。
> 2. Class对象指针:4字节，指向对象对应class对象的内存地址。
> 3. 对象实际数据:对象所有成员变量。
> 4. 对齐:对齐填充字节，按照8个字节填充        
> 32位：Header(标记头4字节 + 对象指针4字节） + int(4字节）+ 对齐（4) = 16字节  
> 64位：Header(标记头8字节 + 对象指针8字节） + int(4字节）+ 对齐（4) = 24字节   
> 64位（启指针压缩）开：Header(标记头8字节 + 对象指针4字节） + int(4字节）+ 对齐（0) = 16字节   

### 8.Vector、ArrayList、LinkedList有何区别
- Vector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素
- ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。
- LinkedList 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的，其进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢。
> JDK8中关于集合的很多方法都是实现在Collection这样的接口里，这是JDK8的新特性，接口里面可以写默认方法
> JDK9中提供了一系列的of方法，如List.of(),Set.of(),大大简化了构建小容器的代码量，并且其返回结果值拥有不可变性，操作时避免了线程安全和扩容的烦恼。

### 9.Java 提供的默认排序算法
在回答这个问题之前，因为需要区分是 Arrays.sort() 还是 Collections.sort() （底层是调用 Arrays.sort()）；什么数据类型；多大的数据集（太小的数据集，复杂排序是没必要的，Java 会直接进行二分插入排序）等
- 对于原始数据类型，目前使用的是所谓双轴快速排序（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序
- 而对于对象数据类型，目前则是使用TimSort，思想上也是一种归并和二分插入排序（binarySort）结合的优化排序算法。TimSort 并不是 Java 的独创，简单说它的思路是查找数据集中已经排好序的分区（这里叫 run），然后合并这些分区来达到排序的目的。
> Java 8 引入了并行排序算法（直接使用 parallelSort 方法），这是为了充分利用现代多核处理器的计算能力，底层实现基于 fork-join 框架（专栏后面会对 fork-join 进行相对详细的介绍），当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；
> 但是，当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境

### 10.对比Hashtable、HashMap、TreeMap有什么不同？

